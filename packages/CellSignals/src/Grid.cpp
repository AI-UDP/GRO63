/*
 * Copyright (C) Sandra Sáez Raspeño - All Rights Reserved
 *
 * This file is part of Cellsignals.
 *
 * All information contained in this package is, and remains the property of
 * Sandra Sáez Raspeño. Copy and distribution of CellSignals or any result
 * generated by it is strictly forbidden unless prior written permission is
 * obtained from Sandra Sáez Raspeño.
 */

/**********************************************************************/
/*                                                                    */
/*                     GRID CLASS IMPLEMENTATION                      */
/*                                                                    */
/**********************************************************************/

#include "Grid.h"
#include <string>
#include <stdlib.h>

using namespace _structures;

/******************* Constructor and Destructor ***********************/

template <class C>
Grid<C>::Grid(unsigned int len, unsigned int cellSize, int neighborhood) :len(len), size(cellSize), neighborhood(neighborhood) {
  vector<vector<C*> > newGrid(len, vector<C*>(len));

  for (unsigned int row = 0; row < len; row++) {
    for (unsigned int col = 0; col < len; col++) {
      newGrid[row][col] = new C;
    }
  }

  grid = newGrid;
  sig = std::vector<GSignal*>();
  reactions = std::vector<GReaction*>();
}

// Specialized template for BlockCell type because it receives an optional parameter (block_capacity)
// template <>
// Grid<BlockCell>::Grid(int block_capacity, unsigned int len, unsigned int cellSize, int neighborhood) :len(len), size(cellSize), neighborhood(neighborhood) {
//   vector<vector<BlockCell*> > newGrid(len, vector<BlockCell*>(len));

//   for (unsigned int row = 0; row < len; row++) {
//     for (unsigned int col = 0; col < len; col++) {
//       newGrid[row][col] = new BlockCell;
//       newGrid[row][col]->setCapacity(block_capacity);
//     }
//   }

//   grid = newGrid;
//   sig = std::vector<GSignal*>();
//   reactions = std::vector<GReaction*>();
// }

template <class C>
Grid<C>::~Grid() {
  for (unsigned int row = 0; row < this->len; row++) {
    this->grid[row].clear();
    vector<C*>().swap(this->grid[row]);
  }

  std::vector<GSignal*>::iterator it_signal;
  for (it_signal = this->sig.begin(); it_signal != this->sig.end(); it_signal++) {
    this->sig.clear();
    vector<GSignal*>().swap(this->sig);
  }
}

/************************** Getters and Setters ***********************/

template <class C>
unsigned int Grid<C>::getLen() {
  return this->len;
}

template <class C>
unsigned int Grid<C>::getCellSize() {
  return this->size;
}

template <class C>
int Grid<C>::getNeighborhood() {
  return this->neighborhood;
}

template <class C>
void Grid<C>::setLen(unsigned int newLen) {
  this->len = newLen;
}

template <class C>
void Grid<C>::setSize(unsigned int newSize) {
  this->size = newSize;
}

template <class C>
void Grid<C>::setNeighborhood(int newNeigh) {
  this->neighborhood = newNeigh;
}

template <class C>
void Grid<C>::setGrid(std::vector<std::vector<C*> > newGrid) {
  this->grid = newGrid;
}

template <class C>
std::vector<std::vector<C*> > Grid<C>::getGrid() {
  return this->grid;
}

template <class C>
std::vector<GSignal*> Grid<C>::getSignalsVector() {
  return this->sig;
}

template <class C>
std::vector<GReaction*> Grid<C>::getReactionVector() {
  return this->reactions;
}

template <class C>
void Grid<C>::setSignalsVector(std::vector<GSignal*> newVec) {
  this->sig = newVec;
}

template <class C>
void Grid<C>::setSignalMatrix(int signal_id, std::vector<std::vector<float> > newMatrix) {
  for (auto& it : this->sig) {
    if (it->get_id() == signal_id)
      it->set_Matrix(newMatrix);
  }
}

/*******************  Auxiliary functions ****************************/

template <class C>
std::vector<C*> Grid<C>::create_and_fill_vector(unsigned int len) {
  vector<C*> newvector(len);

  for (unsigned int i = 0; i < len; i++) {
    newvector[i] = new C;
  }

  return newvector;
}


template <class C>
unsigned int Grid<C>::_getCellsInter(interval_t inter) {
  unsigned int diffRows = inter.bottom.row - inter.top.row;
  unsigned int diffCols = inter.bottom.col - inter.top.col;

  return (diffRows*diffCols);
}

template <class C>
bool Grid<C>::_outOfBounds(vp_t vpoint) {
  return (vpoint.x <= this->getCellSize() || vpoint.x >= ((this->getLen()-1)*this->getCellSize()) ||
	  vpoint.y <= this->getCellSize() || vpoint.y >= ((this->getLen()-1)*this->getCellSize()));
}

template <class C>
unsigned int Grid<C>::_cellsToResize(vp_t vpoint) {
  double max_dist_x, max_dist_y;

  if (vpoint.x <= 0) {
    max_dist_x = -vpoint.x;
  } else if (vpoint.x >= this->getLen()) {
    max_dist_x = vpoint.x-(this->getLen()*this->getCellSize());
  } else {
    max_dist_x = 0;
  }

  if (vpoint.y <= 0) {
    max_dist_y = -vpoint.y;
  } else if (vpoint.y >= this->getLen()) {
    max_dist_y = vpoint.y-this->getLen();
  } else {
    max_dist_y = 0;
  }

  double max = std::max(max_dist_x, max_dist_y);
  return (floor(max/(this->getCellSize()))+1)*3;
}

template <class C>
unsigned int Grid<C>::_maxCellsToResize(vp_t point, vp_t top, vp_t bottom) {
  unsigned int cellsP, cellsT, cellsB;
  cellsP = _cellsToResize(point);
  cellsT = _cellsToResize(top);
  cellsB = _cellsToResize(bottom);
  unsigned int max = 0;

  if ((cellsP >= cellsT) && (cellsP >= cellsB)) {
    max = cellsP;
  }
  if ((cellsT >= cellsP) && (cellsT >= cellsB)) {
    max = cellsT;
  }
  if ((cellsB >= cellsP) && (cellsB >= cellsT)) {
    max = cellsB;
  }

  return max;
}

template <class C>
bool Grid<C>::_existSignal(int id) {
  for (auto& it : this->sig) {
    if (it->get_id() == id)
      return true;
  }

  return false;
}

template <class C>
bool Grid<C>::_signalReachBorder() {
  for (auto& it : this->sig) {
    // Look for sig in first and last row
    for (unsigned int col = 1; col < this->getLen()-1; col++) {
      auto cellF = this->grid[1][col];
      auto cellL = this->grid[this->getLen()-2][col];

      if (cellF->getValue((*it).get_id()) > DIFF_THRESHOLD || cellL->getValue((*it).get_id()) > DIFF_THRESHOLD) {
	return true;
      }      
    }

    // Look for sig in first and last col
    for (unsigned int row = 1; row < this->getLen()-1; row++) {
      auto cellF = this->grid[row][1];
      auto cellL = this->grid[row][this->getLen()-2];

      if (cellF->getValue((*it).get_id()) > DIFF_THRESHOLD || cellL->getValue((*it).get_id()) > DIFF_THRESHOLD) {
	return true;
      }
    }
  }
  
  return false;
}

template <class C>
float Grid<C>::_cellsToResizeBySignals() {
  float factor = ((this->getLen()*this->getCellSize())/this->getCellSize());
  return (factor/this->getCellSize());
}

template <class C>
double Grid<C>::_signalC(int id, unsigned int row, unsigned int col) {
  return (this->grid[row][col]->getValue(id));
}

/************** Auxiliary functions -- Signals operations ***************/

template <class C>
void Grid<C>::_find_and_setTimer(unsigned int row, unsigned int col, int signal_id) {
  std::vector<GSignal*>::iterator it_signal;
   for (it_signal = this->sig.begin(); it_signal != this->sig.end(); it_signal++) {
    int id = (*it_signal)->get_id();
    if (signal_id == id) {
      //double kdeg = (*it_signal)->get_kdeg();
      this->grid[row][col]->_setTimer(signal_id, 0);
    }
   }
}


template <class C>
void Grid<C>::_emit(unsigned int row, unsigned int col, int id, double concentration) {
  if (this->grid[row][col]->_existSignal(id)) {
    this->grid[row][col]->incSignal(id, concentration);
  } else {
    this->grid[row][col]->insertSignal(id);
    // Set the timer. This action only has effect in the case of digital dignals
    _find_and_setTimer(row, col, id);
    this->grid[row][col]->incSignal(id, concentration);
  }
}

template <class C>
void Grid<C>::_absorb(unsigned int row, unsigned int col, int id, double concentration) {
  double available = this->grid[row][col]->getValue(id);
  if ((available - concentration) > 0) {
    this->grid[row][col]->decSignal(id, concentration);
  } else if (available > 0) {
    this->grid[row][col]->decSignal(id, available);
  }
}

/************** Member functions -- Grid operations ***************/

template <class C>
double Grid<C>::getCentre() {
  return (getLen()*getCellSize())/2.0;  
}

template <class C>
C* Grid<C>::getCell(unsigned int row, unsigned int col) {
  return this->grid[row][col];
}

template <class C>
void Grid<C>::resize(unsigned int nCells) {

  for (unsigned int row = 0; row < this->len; row++) {
    for (unsigned int newcols = 0; newcols < nCells; newcols++) {
      C* newcell_front = new C; C* newcell_back = new C;
      this->grid[row].insert(this->grid[row].begin(), newcell_front);
      this->grid[row].push_back(newcell_back);
    }
  }

  for (unsigned int newcols = 0; newcols < nCells; newcols++) {
    vector<C*> newdeque_front = create_and_fill_vector(this->len+(nCells*2));
    vector<C*> newdeque_back = create_and_fill_vector(this->len+(nCells*2));

    this->grid.insert(this->grid.begin(), newdeque_front);
    this->grid.push_back(newdeque_back);
  }

  this->len = this->grid.size();
}


/************** Member functions -- Sig operations ***************/

template <class C>
void Grid<C>::add_signal(int id, double kdiff, double kdeg, std::vector<std::vector<float> > matrix, int cycles) {
  // Force matrix with neighborhood == 4 (prevent user failures)
  if (neighborhood == 4) {
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
	if (i != 1 && j != 1) {
	  matrix[i][j] = 0.0;
	}
      }
    }
  }

  // Check that the sum of neighbors it is the same that the central value
  float sum = 0;
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      if (i != 1 || j != 1) {
	sum += matrix[i][j];
      }
    }
  }

  if (-sum != matrix[1][1]) {
    matrix[1][1] = -sum;
  }
  
  GSignal* newsig = new GSignal(id, kdiff, kdeg, matrix, cycles);
  this->sig.push_back(newsig); 
}

template <class C>
void Grid<C>::add_signal(int id, double kdiff, double kdeg, int cycles) {
  // Create a matrix with each field = 1/neighborhood
  std::vector<std::vector<float> > matrix(3, vector<float>(3));

  if (neighborhood == 8) {
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
	matrix[i][j] = (1.0/this->neighborhood);
	if (i == 1 && j == 1) {
	  matrix[i][j] = -1.0;
	}
      }
    }
  } else if (neighborhood == 4) {
    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
	matrix[i][j] = (1.0/this->neighborhood);
	if (i == 1 && j == 1) {
	  matrix[i][j] = -1.0;
	} else if (i != 1 && j != 1) {
	  matrix[i][j] = 0.0;
	}
      }
    }
  }
  
  GSignal* newsig = new GSignal(id, kdiff, kdeg, matrix, cycles);
  this->sig.push_back(newsig); 
}

template <class C>
void Grid<C>::emit_signal(int id, double concentration, double coords[4], std::string mode) {
  rp_t point; point.x = coords[0]; point.y = coords[1];
  point.lengthX = coords[2]; point.lengthY = coords[3];
  
  vp_t virtualP = _getVirtual(point, this->len, this->size);
  vp_t vtop = _getTopV(point, this->len, this->size);
  vp_t vbottom = _getBottomV(point, this->len, this->size);

  if (_outOfBounds(virtualP) || _outOfBounds(vtop) || _outOfBounds(vbottom)) {
    unsigned int ncells = _maxCellsToResize(virtualP, vtop, vbottom);
    this->resize(ncells);
  }

  
  if (_existSignal(id)) {

    if (mode == "exact") {
      point.lengthX = 0; point.lengthY = 0;
      interval_t inter = _getInterval(point, this->len, this->size);
     _emit(inter.top.row, inter.top.col, id, concentration);
    } else if (mode == "average") {
      interval_t inter = _getInterval(point, this->len, this->size);
      double averageC = concentration/_getCellsInter(inter);
      for (unsigned int i = inter.top.row; i <= (inter.bottom.row); i++) {
	for (unsigned int j = inter.top.col; j <= (inter.bottom.col); j++) {
	  _emit(i, j, id, averageC);
	}
      }
    } else if (mode == "area") {
      interval_t inter = _getInterval(point, this->len, this->size);
      for (unsigned int i = inter.top.row; i <= (inter.bottom.row); i++) {
	for (unsigned int j = inter.top.col; j <= (inter.bottom.col); j++) {
	  _emit(i, j, id, concentration);
	}
      }
    }
  } 
}

template <class C>
void Grid<C>::absorb_signal(int id, double concentration, double coords[4], std::string mode) {
  rp_t point; point.x = coords[0]; point.y = coords[1];
  point.lengthX = coords[2]; point.lengthY = coords[3];

  vp_t virtualP = _getVirtual(point, this->len, this->size);
  vp_t vtop = _getTopV(point, this->len, this->size);
  vp_t vbottom = _getBottomV(point, this->len, this->size);

  if (_outOfBounds(virtualP) || _outOfBounds(vtop) || _outOfBounds(vbottom)) {
    return;
  }

  if (_existSignal(id)) {

    if (mode == "exact") {
      point.lengthX = 0; point.lengthY = 0;
      interval_t inter = _getInterval(point, this->len, this->size);
      _absorb(inter.top.row, inter.top.col, id, concentration);
    } else if (mode == "area") {
      interval_t inter = _getInterval(point, this->len, this->size);
      for (unsigned int i = inter.top.row; i <= (inter.bottom.row); i++) {
	for (unsigned int j = inter.top.col; j <= (inter.bottom.col); j++) {
	  _absorb(i, j, id, concentration);
	}
      }
    } else if (mode == "average") {
      interval_t inter = _getInterval(point, this->len, this->size);
      double averageC = concentration/_getCellsInter(inter);
      for (unsigned int i = inter.top.row; i <= (inter.bottom.row); i++) {
	for (unsigned int j = inter.top.col; j <= (inter.bottom.col); j++) {
	  _absorb(i, j, id, averageC);
	}
      }
    } else if (mode == "random") {
      interval_t inter = _getInterval(point, this->len, this->size);
      srand((unsigned int)time(NULL));
      int rRow = rand() % ((inter.bottom.row+1) - inter.top.row) + inter.top.row;
      int rCol = rand() % ((inter.bottom.col+1) - inter.top.col) + inter.top.col;
      _absorb(rRow, rCol, id, concentration);
    }
  }
}


template <class C>
double Grid<C>::getSignalValue(int id, double coords[4], std::string mode) {
  rp_t point; point.x = coords[0]; point.y = coords[1];
  point.lengthX = coords[2]; point.lengthY = coords[3];

  vp_t virtualP = _getVirtual(point, this->len, this->size);
  vp_t vtop = _getTopV(point, this->len, this->size);
  vp_t vbottom = _getBottomV(point, this->len, this->size);

  if (_outOfBounds(virtualP) || _outOfBounds(vtop) || _outOfBounds(vbottom)) {
    return -1;
  }
  
  if (_existSignal(id)) {
    if (mode == "exact") {
      point.lengthX = 0; point.lengthY = 0;
      interval_t inter = _getInterval(point, this->len, this->size);
      return this->grid[inter.top.row][inter.bottom.col]->getValue(id);
    } else if (mode == "area") {
      interval_t inter = _getInterval(point, this->len, this->size);
      double sum = 0.0;
      for (unsigned int i = (inter.top.row); i < (inter.bottom.row); ++i) {
	for (unsigned int j = (inter.top.col); j < (inter.bottom.col); ++j) {
	  sum += this->grid[i][j]->getValue(id);
	}
      }
      return sum;
    }
  }
  return -1;
}

// template <class C>
// double Grid<C>::getSignalValueRange(int id, double coords[4]) {
//   rp_t point; point.x = coords[0]; point.y = coords[1];
//   point.lengthX = coords[2]; point.lengthY = coords[3];

//   vp_t virtualP = _getVirtual(point, this->len, this->size);
//   vp_t vtop = _getTopV(point, this->len, this->size);
//   vp_t vbottom = _getBottomV(point, this->len, this->size);

//   if (_outOfBounds(virtualP) || _outOfBounds(vtop) || _outOfBounds(vbottom)) {
//     return -1;
//   }
  
//   if (_existSignal(id)) {
//     interval_t inter = _getInterval(point, this->len, this->size);
    
//     double sum = 0.0;
//     for (unsigned int i = (inter.top.row); i < (inter.bottom.row); ++i) {
//       for (unsigned int j = (inter.top.col); j < (inter.bottom.col); ++j) {
// 	sum += this->grid[i][j]->getValue(id);
//       }
//     }
//     return sum;
//   }
//   return -1;
// }

template <class C>
void Grid<C>::setSignalValue(int id, double concentration, double coords[4], std::string mode) {
  rp_t point; point.x = coords[0]; point.y = coords[1];
  point.lengthX = coords[2]; point.lengthY = coords[3];

  vp_t virtualP = _getVirtual(point, this->len, this->size);
  vp_t vtop = _getTopV(point, this->len, this->size);
  vp_t vbottom = _getBottomV(point, this->len, this->size);

  if (_outOfBounds(virtualP) || _outOfBounds(vtop) || _outOfBounds(vbottom)) {
    return;
  }
  
  if (_existSignal(id)) {
    
    if (mode == "exact") {
      point.lengthX = 0; point.lengthY = 0;
      interval_t inter = _getInterval(point, this->len, this->size);
      this->grid[inter.top.row][inter.bottom.col]->setValue(id, concentration);
    } else if (mode == "area") {
      interval_t inter = _getInterval(point, this->len, this->size);
      for (unsigned int i = (inter.top.row); i < (inter.bottom.row); ++i) {
	for (unsigned int j = (inter.top.col); j < (inter.bottom.col); ++j) {
	  this->grid[inter.top.row][inter.bottom.col]->setValue(id, concentration);
	}
      }
    }
  }
}

/************* Member functions -- Reaction functions ***************/

template <class C>
void Grid<C>::add_reaction(float rate, std::vector<int> reactants, std::vector<int> products) {
  GReaction* reaction = new GReaction(rate);

  for (int r = 0; r < reactants.size(); r++) {
    if (_existSignal(reactants[r])) {
      reaction->add_reactant(reactants[r]);
    } else {
      printf("The signal reactive doesn't exist.\n");
      return;
    }
	
  }

  for (int p = 0; p < products.size(); p++) {
    if (_existSignal(products[p])) {
      reaction->add_product(products[p]);
    } else {
      printf("The signal product doesn't exist.\n");
      return;
    }
  }

  this->reactions.push_back(reaction);
}


/************************ Update grid function ************************/

template <class C>
void Grid<C>::update(std::string method, float opt) {
  // if (_signalReachBorder() && (this->getLen() >= 200))  {
  //   exit(127);
  // }

  if (_signalReachBorder()) {
    resize(ceil(_cellsToResizeBySignals()/2));
  }

  if (this->reactions.size() > 0) {
    // Apply reaction
    reaction(opt);
  }
  
  if (method == "gro_original") {
    original_diff(opt);
  } else if (method == "matrix") {
    matrix_diff(opt);
  } else if (method == "digital") {
    // If the choosen method is "digital" then the float parameter
    // its going to be the probability.
    random_walk_block(opt);
  } else if (method == "digital_proportion") {
    proportional_random_walk(opt);
  }
}

template class Grid<CSCell>;
template class Grid<DBCell>;
//template class Grid<BlockCell>;
